#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void createNode(const char* name) {
    printf("I am process %s, my PID is %d, my Parent PID is %d\n", name, getpid(), getppid());
}

int main() {
    pid_t pid1, pid2;

    // Root Node: 10
    createNode("Root (10)");

    // Fork left child of root (6)
    pid1 = fork();
    if (pid1 == 0) {
        createNode("Node (6)");

        // Fork left child of node 6 (4)
        pid_t pid3 = fork();
        if (pid3 == 0) {
            createNode("Node (4)");
            exit(0);  // End the process after printing
        }

        // Fork right child of node 6 (8)
        pid_t pid4 = fork();
        if (pid4 == 0) {
            createNode("Node (8)");
            exit(0);
        }

        // Wait for both children of node 6 to finish
        wait(NULL);
        wait(NULL);
        exit(0);
    }

    // Fork right child of root (18)
    pid2 = fork();
    if (pid2 == 0) {
        createNode("Node (18)");

        // Fork left child of node 18 (15)
        pid_t pid5 = fork();
        if (pid5 == 0) {
            createNode("Node (15)");
            exit(0);
        }

        // Fork right child of node 18 (21)
        pid_t pid6 = fork();
        if (pid6 == 0) {
            createNode("Node (21)");
            exit(0);
        }

        // Wait for both children of node 18 to finish
        wait(NULL);
        wait(NULL);
        exit(0);
    }

    // Wait for both children of root to finish
    wait(NULL);
    wait(NULL);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>  // Include this for wait()

void createNode(const char* name) {
    printf("I am process %s, my PID is %d, my Parent PID is %d\n", name, getpid(), getppid());
}

int main() {
    pid_t pid1, pid2;

    // Root Node: 10
    createNode("Root (10)");

    // Fork left child of root (6)
    pid1 = fork();
    if (pid1 == 0) {
        createNode("Node (6)");

        // Fork left child of node 6 (4)
        pid_t pid3 = fork();
        if (pid3 == 0) {
            createNode("Node (4)");
            exit(0);  // End the process after printing
        }

        // Fork right child of node 6 (8)
        pid_t pid4 = fork();
        if (pid4 == 0) {
            createNode("Node (8)");
            exit(0);
        }

        // Wait for both children of node 6 to finish
        wait(NULL);
        wait(NULL);
        exit(0);  // End the process for node 6
    }

    // Fork right child of root (18)
    pid2 = fork();
    if (pid2 == 0) {
        createNode("Node (18)");

        // Fork left child of node 18 (15)
        pid_t pid5 = fork();
        if (pid5 == 0) {
            createNode("Node (15)");
            exit(0);
        }

        // Fork right child of node 18 (21)
        pid_t pid6 = fork();
        if (pid6 == 0) {
            createNode("Node (21)");
            exit(0);
        }

        // Wait for both children of node 18 to finish
        wait(NULL);
        wait(NULL);
        exit(0);  // End the process for node 18
    }

    // Wait for both children of root to finish
    wait(NULL);
    wait(NULL);

    return 0;
}

1. Basic Fork Program
c
Copy code
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("This is the child process. PID: %d\n", getpid());
    } else {
        printf("This is the parent process. PID: %d\n", getpid());
    }
    return 0;
}
2. Check Parent-Child Relationship Using getpid() and getppid()
c
Copy code
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("Child Process: PID = %d, Parent PID = %d\n", getpid(), getppid());
    } else {
        printf("Parent Process: PID = %d\n", getpid());
    }
    return 0;
}
3. Process Termination with exit()
c
Copy code
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("Child process terminating. PID: %d\n", getpid());
        exit(0);  // Child exits
    } else {
        sleep(3);  // Parent continues for a while
        printf("Parent process. PID: %d\n", getpid());
    }
    return 0;
}
4. Prevent Zombie Processes Using wait()
c
Copy code
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("Child process. PID: %d\n", getpid());
    } else {
        wait(NULL);  // Parent waits for the child to finish
        printf("Parent process. PID: %d\n", getpid());
    }
    return 0;
}
5. Simulate Orphan Process
c
Copy code
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        sleep(5);  // Child sleeps
        printf("Orphan process. PID: %d, New Parent PID: %d\n", getpid(), getppid());
    } else {
        printf("Parent process exiting. PID: %d\n", getpid());
        exit(0);  // Parent exits
    }
    return 0;
}
6. Create Multiple Child Processes Using Multiple fork() Calls
c
Copy code
#include <stdio.h>
#include <unistd.h>

int main() {
    fork();
    fork();
    printf("Process PID: %d, Parent PID: %d\n", getpid(), getppid());
    return 0;
}
Explanation: This program creates 4 processes (2 fork() calls result in 
2
2
2 
2
  processes).
7. Create a Chain of Processes (Parent-Child-Grandchild)
c
Copy code
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid1 = fork();  // First fork to create a child

    if (pid1 == 0) {
        pid_t pid2 = fork();  // Child creates a grandchild

        if (pid2 == 0) {
            printf("Grandchild process. PID: %d, Parent PID: %d\n", getpid(), getppid());
        } else {
            printf("Child process. PID: %d, Parent PID: %d\n", getpid(), getppid());
        }
    } else {
        printf("Parent process. PID: %d\n", getpid());
    }
    return 0;
}
8. Race Condition Simulation
c
Copy code
#include <stdio.h>
#include <unistd.h>

int shared_var = 0;

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        for (int i = 0; i < 5; i++) {
            shared_var++;
            printf("Child: %d\n", shared_var);
        }
    } else {
        for (int i = 0; i < 5; i++) {
            shared_var++;
            printf("Parent: %d\n", shared_var);
        }
    }
    return 0;
}
Explanation: This program demonstrates a race condition. Both the parent and child processes update the same variable, leading to unpredictable results.
9. Fork Bomb Detection and Prevention
c
Copy code
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    int max_processes = 10;
    int count = 0;

    while (count < max_processes) {
        pid_t pid = fork();
        if (pid == 0) {
            printf("Child process. PID: %d\n", getpid());
            exit(0);  // Child exits immediately
        }
        count++;
    }
    return 0;
}
Explanation: This program ensures that only 10 child processes are created to prevent a fork bomb.
10. Implement a Mini Shell Using fork() and exec()
c
Copy code
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char command[100];

    while (1) {
        printf("MiniShell> ");
        fgets(command, 100, stdin);
        command[strcspn(command, "\n")] = 0;  // Remove newline

        if (strcmp(command, "exit") == 0) {
            break;  // Exit the shell
        }

        pid_t pid = fork();
        if (pid == 0) {
            execlp(command, command, (char *)NULL);  // Execute command
            perror("Command failed");
            exit(1);
        } else {
            wait(NULL);  // Parent waits for child to finish
        }
    }

    return 0;
}